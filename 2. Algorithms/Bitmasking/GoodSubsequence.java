/** A subsequence of a given string is generated by
deleting zero or more characters from a string,
then concatenating the remaining characters. 

A good subsequence is one where the frequency of
each character is the same. Given a string that
consists of n Latin letters, determine how many
good subsequences it contains. 

Since the answer can be quite large, compute its modulo (109+7).
Note: An empty subsequence is not a good
subsequence.
Example
word = "abca"
A total of 15 non-empty subsequences can be
formed fronn words.
The only subsequences that are not good, are
"aba","aca" and "abca" as the frequencies of
character "a" is 2 and every other character is 1.
The total number oi good subsequences is 15-3 = 12 mod 10^7+9 == 12 .
 */

import java.util.*;

class GoodSubsequence {

  static final int MOD = 1000000007;

  // Method to calculate factorial
  public static long factorial(int n) {
    long fact = 1;
    for (int i = 2; i <= n; i++) {
      fact *= i;
    }
    return fact;
  }

  // Method to calculate permutations P(n, r)
  public static long permutation(int n, int r) {
    return factorial(n) / factorial(n - r);
  }

  // Method to calculate combinations C(n, r)
  public static long combination(int n, int r) {
    return factorial(n) / (factorial(r) * factorial(n - r));
  }

  public static boolean isGoodSequence(String s) {
    int[] count = new int[26];
    for (char ch : s.toCharArray()) {
      count[ch - 'a']++;
    }
    HashSet<Integer> hash = new HashSet<>();
    for (int val : count) {
      if (val != 0) {
        hash.add(val);
        if (hash.size() >= 2) return false;
      }
    }
    return true;
  }

  // Brute Force code : O(2^n)
  public static int count(String s) {
    int n = s.length();
    int cnt = 0;

    // Loop over all possible subsequences using bitmask
    for (int mask = 1; mask < (1 << n); mask++) {
      StringBuilder subsequence = new StringBuilder();
      for (int i = 0; i < n; i++) {
        if ((mask & (1 << i)) != 0) {
          subsequence.append(s.charAt(i));
        }
      }

      // Check if the subsequence is good
      if (isGoodSequence(subsequence.toString())) {
        cnt++;
      }
    }

    return cnt % MOD;
  }

  // Optimised Code : O(n)
  public static int count2(String s) { // Count array for each character with a maximum value tracker
    int[] characterCount = new int[26];
    int maxCount = 1;

    // Calculate character counts and find the max count
    for (int i = 0; i < s.length(); ++i) {
      maxCount = Math.max(maxCount, ++characterCount[s.charAt(i) - 'a']);
    }

    // Initialize the answer value which will be the final count
    long answer = 0;

    // Iterate over all possible subsequence lengths
    for (int i = 1; i <= maxCount; ++i) {
      long countForLength = 1;
      for (int j = 0; j < 26; ++j) {
        if (characterCount[j] >= i) {
          countForLength =
            countForLength * (combination(characterCount[j], i) + 1) % MOD;
        }
      }
      // Subtract 1 because we are excluding the empty subsequence
      answer = (answer + countForLength - 1) % MOD;
    }

    // Return the result after casting to int
    return (int) answer;
  }

  public static void main(String[] args) {
    System.out.println(count("abca")); // Expected output: 12
    System.out.println(count2("abca")); // Expected output: 12
  }
}
