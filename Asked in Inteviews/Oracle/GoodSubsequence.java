/** A subsequence of a given string is generated by
deleting zero or more characters from a string,
then concatenating the remaining characters. 

A good subsequence is one where the frequency of
each character is the same. Given a string that
consists of n Latin letters, determine how many
good subsequences it contains. 

Since the answer can be quite large, compute its modulo (109+7).
Note: An empty subsequence is not a good
subsequence.
Example
word = "abca"
A total of 15 non-empty subsequences can be
formed fronn words.
The only subsequences that are not good, are
"aba","aca" and "abca" as the frequencies of
character "a" is 2 and every other character is 1.
The total number oi good subsequences is 15-3 = 12 mod 10^7+9 == 12 .
 */

import java.util.*;

class GoodSubsequence {

  static final int MOD = 1000000007;

  // Method to calculate factorial
  public static long factorial(int n) {
    long fact = 1;
    for (int i = 2; i <= n; i++) {
      fact *= i;
    }
    return fact;
  }

  // Method to calculate permutations P(n, r)
  public static long permutation(int n, int r) {
    return factorial(n) / factorial(n - r);
  }

  // Method to calculate combinations C(n, r)
  public static long combination(int n, int r) {
    return factorial(n) / (factorial(r) * factorial(n - r));
  }

  public static boolean isGoodSequence(String s) {
    int[] count = new int[26];
    for (char ch : s.toCharArray()) {
      count[ch - 'a']++;
    }
    HashSet<Integer> hash = new HashSet<>();
    for (int val : count) {
      if (val != 0) {
        hash.add(val);
        if (hash.size() >= 2) return false;
      }
    }
    return true;
  }

  // Brute Force code : O(2^n)
  public static int count(String s) {
    int n = s.length();
    int cnt = 0;

    // Loop over all possible subsequences using bitmask
    for (int mask = 1; mask < (1 << n); mask++) {
      StringBuilder subsequence = new StringBuilder();
      for (int i = 0; i < n; i++) {
        if ((mask & (1 << i)) != 0) {
          subsequence.append(s.charAt(i));
        }
      }

      // Check if the subsequence is good
      if (isGoodSequence(subsequence.toString())) {
        cnt++;
      }
    }

    return cnt % MOD;
  }

  // Optimised Code : O(n)
  public static int count2(String s) { // Count array for each character with a maximum value tracker
    int[] characterCount = new int[26];
    int maxCount = 1;

    // Calculate character counts and find the max count
    for (int i = 0; i < s.length(); ++i) {
      maxCount = Math.max(maxCount, ++characterCount[s.charAt(i) - 'a']);
    }

    // Initialize the answer value which will be the final count
    long answer = 0;

    // Iterate over all possible subsequence lengths
    for (int i = 1; i <= maxCount; ++i) {
      long countForLength = 1;
      for (int j = 0; j < 26; ++j) {
        if (characterCount[j] >= i) {
          countForLength =
            countForLength * (combination(characterCount[j], i) + 1) % MOD;
        }
      }
      // Subtract 1 because we are excluding the empty subsequence
      answer = (answer + countForLength - 1) % MOD;
    }

    // Return the result after casting to int
    return (int) answer;
  }

  public static void main(String[] args) {
    System.out.println(count("abca")); // Expected output: 12
    System.out.println(count2("abca")); // Expected output: 12
  }
}


/**
 * Let's break down the code and the logic behind the `+1` and `-1` in the given context:

### Problem Context
You are trying to determine the number of **good subsequences** in a given string. A good subsequence is one where each character in the subsequence appears the same number of times. 

### Code Explanation
The given code snippet counts the number of good subsequences by iterating through possible lengths of subsequences (`i`) and using combinations to calculate the number of valid subsequences of that length.

### Key Variables:
- **`characterCount[j]`**: The frequency of the j-th character in the string.
- **`maxCount`**: The maximum frequency of any character in the string.
- **`countForLength`**: The number of good subsequences of a particular length `i`.
- **`MOD`**: The modulo value \(10^9 + 7\), used to keep the answer within manageable limits.

### Explanation of `+1` and `-1`
1. **`+1` in the Calculation**:
   - **Purpose**: To account for the case where a character does not appear in the subsequence.
   - **Explanation**: When you are calculating the number of ways to pick `i` characters from `characterCount[j]`, the combination function `combination(characterCount[j], i)` gives you the number of ways to pick `i` characters. By adding `1`, you account for the possibility of not picking that character at all in the subsequence.
   - **Mathematically**: \( (combination(characterCount[j], i) + 1) \) represents both the choices of selecting exactly `i` occurrences and not selecting that character (which is valid in the construction of subsequences).

2. **`-1` in the Calculation**:
   - **Purpose**: To exclude the empty subsequence from the count.
   - **Explanation**: When you calculate `countForLength`, it includes the empty subsequence (where no characters are selected from any of the 26 letters). However, the problem states that an empty subsequence is not a good subsequence, so you subtract 1 to remove it from the final count.
   - **Mathematically**: The formula `countForLength - 1` adjusts the count to exclude the empty subsequence.

### Code Flow Summary:
1. **Outer Loop** (`i = 1` to `maxCount`):
   - Iterates through each possible subsequence length.
  
2. **Inner Loop** (`j = 0` to `25`):
   - For each character in the alphabet, it computes the contribution to subsequences of length `i`.

3. **`countForLength` Calculation**:
   - Computes the total number of subsequences of length `i` using the combination formula and includes cases where characters might not appear at all (hence `+1`).

4. **Adjust for Empty Subsequence**:
   - Subtracts 1 to ensure the empty subsequence is not counted.

5. **Update Answer**:
   - The result for subsequences of length `i` is added to the total answer.

### Example (String "abca"):
For the string "abca":
- **Character counts**: 'a' appears 2 times, 'b' and 'c' appear once each.
- **maxCount**: 2 (since 'a' appears the most, 2 times).

The loops will calculate the number of valid subsequences, ensuring that subsequences like "aba" or "aca" are counted correctly, excluding the empty subsequence.

### Conclusion
The `+1` accounts for the option of not selecting a character in the subsequence, and the `-1` removes the empty subsequence from the final count. This ensures that only non-empty, valid "good" subsequences are considered.
 */