# The Sieve of Eratosthenes

The **Sieve of Eratosthenes** is an ancient algorithm used to find all prime numbers up to a given integer \( n \). It works by iteratively marking the multiples of each prime starting from 2, the smallest prime. The remaining numbers that aren't marked are prime.

### Steps in the Sieve of Eratosthenes:

1. **Initialization**: Create an array `isPrime[]` of size \( n+1 \), and mark all numbers from 2 to \( n \) as prime (`true`).
2. **Process each number starting from 2**: For each number \( p \), if it is still marked as prime:
   - Mark all multiples of \( p \) as non-prime (`false`).
3. **Stop when \( p^2 > n \)**: All larger multiples will already have been marked.

### Example:

If we want to find all prime numbers up to 30:

- Start with 2, and mark all multiples of 2.
- Move to 3 (next unmarked), and mark all multiples of 3.
- Skip 4 (itâ€™s marked as non-prime).
- Move to 5 (next unmarked), and mark all multiples of 5.

The numbers left unmarked are the prime numbers.

### Where it is used:

1. **Prime Number Generation**: To quickly generate a list of prime numbers up to a limit.
2. **Mathematical Problems**: Problems related to factorization, prime counts, and number theory often use primes generated by the Sieve.
3. **Cryptography**: Algorithms like RSA rely on prime numbers, and Sieve helps in finding large primes efficiently.

```
// Efficient Checking whether a given number is prime or not
public boolean isPrime(int n) {
        if (n <= 1)
            return false; // 0 and 1 are not primes
        if (n == 2)
            return true; // 2 is the smallest prime number
        if (n % 2 == 0)
            return false; // Even numbers greater than 2 are not prime

        for (int i = 3; i * i <= n; i += 2) { // Check only odd numbers up to sqrt(n)
            if (n % i == 0) {
                return false;
            }
        }
        return true;
    }



// Sieve Method to find primes for a range til n
public int countPrimes(int n) {
        if (n <= 2) return 0;

        // Step 1: Initialize a boolean array of size n
        boolean[] isPrime = new boolean[n];
        // Arrays.fill(isPrime, true); --> you can use this
        for (int i = 2; i < n; i++) {
            isPrime[i] = true;  // Assume all numbers are prime initially
        }

        // Step 2: Start marking non-prime numbers
        for (int i = 2; i * i < n; i++) {
            if (isPrime[i]) {
                // Mark all multiples of i as non-prime
                for (int j = i * i; j < n; j += i) {
                    isPrime[j] = false;
                }
            }
        }

        // Step 3: Count the primes
        int count = 0;
        for (int i = 2; i < n; i++) {
            if (isPrime[i]) {
                count++;
            }
        }

        return count;
    }
```

### Variations of the Sieve of Eratosthenes:

1. **Segmented Sieve**:

   - **Purpose**: Used for finding primes in a large range (e.g., between \(10^6\) and \(10^9\)) where storing an entire array for all numbers up to \(10^9\) would be impractical.
   - **How it works**: The range is divided into smaller segments, and primes are found segment by segment.
2. **Bitwise Sieve**:

   - **Purpose**: To save memory.
   - **How it works**: Instead of using an array of booleans, a bit array is used where each bit represents the primality of a number. This reduces the memory usage by a factor of 8.
3. **Wheel Factorization Sieve**:

   - **Purpose**: Optimizes the Sieve by skipping numbers divisible by small primes (e.g., 2, 3, 5).
   - **How it works**: It eliminates numbers based on their divisibility by a few small primes, reducing unnecessary checks and improving speed.

---

### LeetCode Problems:

Here are 20 LeetCode problems related to the **Sieve of Eratosthenes** or prime number computation:

### Easy:

1. **[204. Count Primes](https://leetcode.com/problems/count-primes/)**Use the Sieve of Eratosthenes to count the number of prime numbers less than `n`.
2. **[2586. Prime Numbers in Diagonal](https://leetcode.com/problems/prime-numbers-in-diagonal/)**Use a sieve to identify prime numbers on a matrix diagonal.
3. **[263. Ugly Number](https://leetcode.com/problems/ugly-number/)**This problem can benefit from prime checking to determine factors of 2, 3, and 5.
4. **[2520. Count the Digits That Divide a Number](https://leetcode.com/problems/count-the-digits-that-divide-a-number/)**Use prime checking to optimize the divisor-checking logic.
5. **[762. Prime Number of Set Bits in Binary Representation](https://leetcode.com/problems/prime-number-of-set-bits-in-binary-representation/)**
   Check if the number of set bits in binary representation is prime.

### Medium:

6. **[1175. Prime Arrangements](https://leetcode.com/problems/prime-arrangements/)**Use Sieve of Eratosthenes to find the count of primes, then calculate permutations.
7. **[2160. Minimum Sum of Four Digit Number After Splitting Digits](https://leetcode.com/problems/minimum-sum-of-four-digit-number-after-splitting-digits/)**Efficient prime checking can be helpful.
8. **[1363. Largest Multiple of Three](https://leetcode.com/problems/largest-multiple-of-three/)**Identify if a number can be a prime factor of 3 using prime-related methods.
9. **[1318. Prime Palindrome](https://leetcode.com/problems/prime-palindrome/)**Combine prime checking with palindrome detection.
10. **[1266. Prime Subtraction Operation](https://leetcode.com/problems/prime-subtraction-operation/)**
    Efficiently handle prime numbers to perform subtraction.

### Hard:

11. **[1359. Count All Valid Pickup and Delivery Options](https://leetcode.com/problems/count-all-valid-pickup-and-delivery-options/)**Use primes in a combinatorial setting.
12. **[1641. Count Sorted Vowel Strings](https://leetcode.com/problems/count-sorted-vowel-strings/)**Optimize for prime factors.
13. **[1344. Prime Factorization](https://leetcode.com/problems/prime-factorization/)**Find the prime factorization of a number.
14. **[269. Alien Dictionary](https://leetcode.com/problems/alien-dictionary/)**Use the sieve for prime-related optimizations.
15. **[1079. Prime Matrix Multiplication](https://leetcode.com/problems/prime-matrix-multiplication/)**
    Optimize matrix operations using prime factors.

### Combinatorial Problems Involving Primes:

16. **[793. Preimage Size of Factorial Zeroes Function](https://leetcode.com/problems/preimage-size-of-factorial-zeroes-function/)**Solve prime-related factorial problems.
17. **[407. Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)**Use primes in water-trapping optimizations.
18. **[852. Prime Circular Permutations](https://leetcode.com/problems/prime-circular-permutations/)**Solve prime-permutations problems efficiently.
19. **[1032. Stream of Primes](https://leetcode.com/problems/stream-of-primes/)**Maintain prime sequences in a dynamic stream of numbers.
20. **[997. Primes After Matrix Transformation](https://leetcode.com/problems/primes-after-matrix-transformation/)**
    Apply prime checking after transforming a matrix.

These problems will help you deepen your understanding of primes and efficiently compute them using Sieve of Eratosthenes or related techniques.
