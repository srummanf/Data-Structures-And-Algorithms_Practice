Which of following topologies has the highest reliability?

Bus topology

Star topology

Ring topology

Mesh topology
 :

Mesh topology






 :
Pseudocode

double func(int arr[], int 1)

Arrays.sort(arr);

if (1%2!=0)

return (double) arr [1/2];

double res = (double) ((arr[1/2]+arr[(1-1)/2]/2.0);

return res;

Which of the following options given below correctly answers the type of output of the mentioned pseudocode?

Highest Common Factor

Lowest Common Multiple

Median
 :

Median






 :
What is the time complexity of the following pseudocode:

2

Pseudocode

3

Algorithm Search (arr, x):

low = 0

high

length (arr)

while low <= high:

4

5

mid (low + high) / 2

if arr[mid] == x:

6

7

8

9

return mid

elif arr[mid] < x:

low mid + 1

else:

high mid-1

return -1
 :

O(log n)






 :
ements a heap using an array, what is the time complexity of the insert() and extract_max() operations? For heap 
 :

The time complexity for both insert() and extract_max() operations in a heap is O(log n).






 :
In Networking, you are working on the various layers of an OSI model. Now, which of the following represent the functions of a Data Link Leyer (DLL)

Options:

1 Logical addressing

2. Framing

3. Error control

4. Access control

5 Routing

6. Flow control

7. Physical addressing

12.5.6, and 7

2

3

6

7

S

13.4.5 and 6

10

3.4.5.6 and 7

234.6 and 7
 :

2, 3, 4, 6, and 7






 :
function findMedianSortedArrays (numsl, nums2):

nl length of numsl

4

n2 length of nums2

nn1 + n2

new arr = array of size n

5

6

7

8

9

i = 0

j = 0

k = 0

while (i <= nl && j <= n2):

if (i == nl):

10

while (j < n2): new_arr[k++] = nums2 [j++]

break

11

else if (j = n2):

while (i<n1): new arr[k++] = numsl [i++]

break

if (numsl[i] < nums2[j]): new_arr[k++] = numsl [i++] else:

new arr[k++] = nums2 [j++]

if (n % 2 == 0):

return (new_arr[n/2-1] + new_arr[n/2]) / 2

else:

return new_arr[n/2]


Time complexity 
 :

O(n + m)






 :
Based on the following table, what is the output of the SQL query:

STUDENT

ID

NAME

AGE

01

Mike

20

02

Alice

18

03

Mary

25

04

Lisa

NULL

Query:

SQL> SELECT NAME FROM STUDENT WHERE NAME LIKE '%a%' ORDER BY NAME;
 :

The output of the SQL query will be:

Copy code
Alice
Mary





 :
Consider the following set of processes, assumed to have arrived at time 0, in the order PO, P1,..., P4, with the length of the CPU-burst time given in milliseconds. If the priority scheduling scheme is used to allocate the resources, then what is the average waiting time in milliseconds?

Table:

Process

PO

P1

P2

P3

P4

Priority

3

1

4

5

2

Burst time

10

1

2

1

5
 :

To calculate the average waiting time using priority scheduling, we first sort the processes by priority. The lower the number, the higher the priority.

Processes Sorted by Priority:
P1 (Priority 1, Burst Time 1)
P4 (Priority 2, Burst Time 5)
P0 (Priority 3, Burst Time 10)
P2 (Priority 4, Burst Time 2)
P3 (Priority 5, Burst Time 1)
Calculating Waiting Times:
P1: Waiting Time = 0 (starts at time 0)
P4: Waiting Time = 1 (P1's burst time)
P0: Waiting Time = 1 + 5 = 6 (P1 + P4)
P2: Waiting Time = 1 + 5 + 10 = 16 (P1 + P4 + P0)
P3: Waiting Time = 1 + 5 + 10 + 2 = 18 (P1 + P4 + P0 + P2)
Summary of Waiting Times:
P1: 0
P4: 1
P0: 6
P2: 16
P3: 18
Average Waiting Time Calculation:
Average Waiting Time = (0 + 1 + 6 + 16 + 18) / 5 = 41 / 5 = 8.2 ms

Final Answer:
Average Waiting Time = 8.2 milliseconds






 :
Given a binary tree to find the maximum path sum. Identify the missing code in place of line number 14.

Code

class TreeNode:

function _init_(self, val=0, left=None, right=None):

self.val = val

self.left = left

self.right = right

function max_path_sum(root):

max sum = float('-inf')

3

function max gain (node):

nonlocal max_sum

14

if not node:

return 0

15

left_gain max (max_gain (node.left), 0)

right_gain = max (max_gain (node.right), 0)

// line 14

max_sum = max (max_sum, price_newpath)

return node.val + max(left_gain, right_gain)

max_gain (root)

return max sum

Options

1. price_newpath = node.val + left_gain + right_gain

2. price_newpath = left_gain right_gain

3. price_newpath = max(left_gain+ right_gain, left gain, right_gain)

4 price_newpath (node.val, left gain right_gain)
 :

The correct option for line number 14 is:

1. price_newpath = node.val + left_gain + right_gain






 :
public class Main {

public static void main(String[] args) {

Product original new Product ( roduct ("Laptop", 999.99);

Product copy = new Product (original);

copy.name "Tablet";

System.out.println(original.name);

class Product {

String name:

double price;

Product (String n, double p) ( namen: price = p;

Product (Product product) ( this (product.name, product.price);


Output ??
 :

The provided code has some syntax errors. Here’s a corrected version of the code along with the expected output:

java
Copy code
public class Main {

    public static void main(String[] args) {

        Product original = new Product("Laptop", 999.99);
        Product copy = new Product(original);
        copy.name = "Tablet";

        System.out.println(original.name);
    }
}

class Product {

    String name;
    double price;

    Product(String n, double p) {
        name = n;
        price = p;
    }

    Product(Product product) {
        this(product.name, product.price);
    }
}
Output:
Copy code
Laptop
Explanation:
The original product is created with the name "Laptop".
A copy of the original product is created using the copy constructor, which initializes the copy with the same name and price as the original.
Then, the name of the copy is changed to "Tablet", but this does not affect the original.
Finally, the program prints the name of the original, which is "Laptop".





 :
In priority scheduling, which of the following statements about the non-preemptive shortest job first scheduling is correct:

Statements:

1. It selects a waiting process that has the minimum execution time.

2. It can cause starvation in the system.

3. It is a non-greedy algorithm.

4. It has the advantage of containing the minimum average waiting time among all scheduling algorithms.

1, 2, and 4

1. 2. and 3

1 and 3

4

5

2 and 3
 :

The correct statements about the non-preemptive shortest job first scheduling are:

1, 2, and 4






 :
What is the output of the following Pseudocode:

Pseudocode

ABSTRACT CLASS Myciass1:

ABSTRACT STATIC CLASS Myclass2:

SET STATIC VAR INTEGER 10

PUBLIC VOID FUNCTION funel:

//Nothing new is added here

END

STATIC VOID FUNCTION func2:

PRINT 1 //Myclassi.Myclass2.1

END

PUBLIC CLASS Main inherits CLASS Myclagai Myclass2 and defines:

PUBLIC VOID FUNCTION funci:

SET VAR 1-1

PUBLIC FUNCTION Main:

SET OBJECT obj as new Object for Class Main() 

INVOKE obj.funcl

Myclassi.Myclass

INVOKE Myclassi.func2

END
 :

Based on the provided pseudocode, let’s analyze the output step by step.

Breakdown of the Pseudocode
ABSTRACT CLASS Myclass1: This class does not define any methods or properties in the provided pseudocode.

ABSTRACT STATIC CLASS Myclass2: This class has:

A static variable INTEGER 10 (not used in the output).
A public function func1 which does nothing.
A static function func2 that prints 1.
PUBLIC CLASS Main: This class:

Inherits from Myclass1 and Myclass2.
Contains a public function func1 which sets a variable (not relevant for output).
Has a constructor Main that creates an object of Main.
Invokes obj.func1 (which does nothing).
Invokes Myclass2.func2, which prints 1.
Execution Flow
When obj.func1 is invoked, it does nothing.
Then Myclass2.func2 is invoked, which prints 1.
Output
The final output of the pseudocode will be:

Copy code
1





 :
What is the output for the given pseudo code when nums = [3, 4,-1, 1]?

Code

function find (nums):

n = length (nums)

if 1 not in nums:

return 1

for i = 0 to n-1:

if nums [i] <= 0 or nums[i] > n:

nums [i] = 1

for i = 0 to n-1:

a abs (nums[i])

if a == n:

nums[0] = -abs (nums[0])

else:

nums [a] -abs(nums[a])

for i = 1 to n-1:

if nums[i] > 0:

return i

if nums [0] > 0:

return n

return n + 1
 :

To find the output of the given pseudocode when nums = [3, 4, -1, 1], let's go through the code step by step.

Pseudocode Analysis
Initialization:

n = length(nums) → n = 4
The input array is nums = [3, 4, -1, 1].
Check if 1 is in nums:

Since 1 is in nums, we proceed to the next step.
First Loop (for i = 0 to n-1):

This loop modifies values in nums to ensure all numbers are between 1 and n (i.e., between 1 and 4).
Iteration 0: nums[0] = 3 (valid, no change).
Iteration 1: nums[1] = 4 (valid, no change).
Iteration 2: nums[2] = -1 (invalid, so set nums[2] = 1).
Iteration 3: nums[3] = 1 (valid, no change).
After this loop: nums = [3, 4, 1, 1].
Second Loop (for i = 0 to n-1):

This loop is meant to mark indices corresponding to the values in nums.
Iteration 0: a = abs(nums[0]) = 3. Since 3 <= n, we mark nums[3] as negative. Thus, nums = [3, 4, 1, -1].
Iteration 1: a = abs(nums[1]) = 4. Since 4 is equal to n, we mark nums[0] as negative. Thus, nums = [-3, 4, 1, -1].
Iteration 2: a = abs(nums[2]) = 1. We mark nums[1] as negative. Thus, nums = [-3, -4, 1, -1].
Iteration 3: a = abs(nums[3]) = 1. We do not change it again since it's already negative.
After this loop: nums = [-3, -4, 1, -1].
Final Loop (for i = 1 to n-1):

This loop checks for the first positive index starting from 1.
Iteration 1: nums[1] = -4 (not positive).
Iteration 2: nums[2] = 1 (positive). The function returns i, which is 2.
Conclusion
The output of the given pseudocode when nums = [3, 4, -1, 1] is:

Copy code
2





 :
Based on the following tables named 'customers' and 'orders', 

cust id

cust name

address

101

Lisa Davis

Tokyo

107

John Wilson

New York

115

Mary Brown

London

121

Paul Miller

Paris

Table2: orders

order id

cust id

order item

1972

101

Television

3586

107

Refrigerator

2914

115

Grocery

5760

222 Drill machine

Query:

SELECT customers.cust_id,customers.cust_name,customers.address,

orders.order item

FROM customers

INNER JOIN orders

ON customers.cust_id=orders.cust id:
 :

To analyze the provided SQL query and determine its output based on the given tables customers and orders, let's break it down step by step.

Tables Provided
Table 1: customers

sql
Copy code
cust_id  | cust_name     | address
---------|---------------|--------
101     | Lisa Davis    | Tokyo
107     | John Wilson   | New York
115     | Mary Brown    | London
121     | Paul Miller   | Paris
Table 2: orders

yaml
Copy code
order_id | cust_id | order_item
---------|---------|----------------
1972    | 101     | Television
3586    | 107     | Refrigerator
2914    | 115     | Grocery
5760    | 222     | Drill machine
SQL Query Breakdown
sql
Copy code
SELECT customers.cust_id, customers.cust_name, customers.address, orders.order_item
FROM customers
INNER JOIN orders ON customers.cust_id = orders.cust_id;
INNER JOIN: This operation returns only the rows from both tables where there is a match based on the condition specified. In this case, it matches customers.cust_id with orders.cust_id.
Matching Records
Let's see which customers have matching orders:

cust_id 101 (Lisa Davis) has an order in the orders table.
cust_id 107 (John Wilson) has an order in the orders table.
cust_id 115 (Mary Brown) has an order in the orders table.
cust_id 121 (Paul Miller) does not have a corresponding entry in the orders table.
The order with cust_id 222 in the orders table does not match any customer in the customers table, so it will not appear in the results.

Resulting Output
Based on the matches found, the output of the query will be:

sql
Copy code
cust_id | cust_name     | address     | order_item
--------|---------------|-------------|--------------
101     | Lisa Davis    | Tokyo       | Television
107     | John Wilson   | New York    | Refrigerator
115     | Mary Brown    | London      | Grocery
Conclusion
The output of the given SQL query will be:

sql
Copy code
cust_id | cust_name     | address     | order_item
--------|---------------|-------------|--------------
101     | Lisa Davis    | Tokyo       | Television
107     | John Wilson   | New York    | Refrigerator
115     | Mary Brown    | London      | Grocery